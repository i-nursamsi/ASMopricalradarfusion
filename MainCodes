// center the map
Map.centerObject(roi);



//South Kalimantan as ROI for current version of the code. 
var SK = ee.FeatureCollection(SouthKalimantan);
Map.addLayer(SK, {}, "South Kalimantan");




//merge the training class
var classNames = ASGM.merge(Forest).merge(nonforestVeg).merge(settlements).merge(bareSoil).merge(waterBody);

//check the class
print(classNames);

var startDate = '2020-01-01';
var endDate = '2020-12-31';

//masking the cloud function
function maskL8srClouds(image) {
  // Bits 3 and 5 are cloud shadow and cloud, respectively.
  var cloudShadowBitMask = (1 << 3);
  var cloudsBitMask = (1 << 5);
  // Get the pixel QA band.
  var qa = image.select('pixel_qa');
  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0)
                .and(qa.bitwiseAnd(cloudsBitMask).eq(0));
  return image.updateMask(mask);
}

//calling the landsat 8 image
var l8 = ee.ImageCollection('LANDSAT/LC08/C01/T1_SR');
var l8Filt = l8.filterBounds(SK)
    .filterDate(startDate,endDate)
    .filterMetadata('CLOUD_COVER','less_than',50);
    //.map(maskL8srClouds);


var compositel8 = l8Filt.median().clip(SK);

Map.addLayer(compositel8,{bands:['B4','B3','B2'],min:300,max:3000},
             'Composite L8 2019');


/// ------ ADDING Sentinel 2 products ----- /////
// We will use the Sentinel-2 Surface Reflection product.
// This dataset has already been atmospherically corrected
var s2 = ee.ImageCollection("COPERNICUS/S2_SR");

// Function to mask clouds S2
function maskS2srClouds(image) {
  var qa = image.select('QA60');

  // Bits 10 and 11 are clouds and cirrus, respectively.
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;

  // Both flags should be set to zero, indicating clear conditions.
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0)
      .and(qa.bitwiseAnd(cirrusBitMask).eq(0));

  return image.updateMask(mask).divide(10000);
}

//a function to rename the band
function renameBandsETM(image) {
    var bands = ['B2','B3', 'B4', 'B5'];
    var new_bands = ['sB2','sB3', 'sB4', 'sB5'];
    return image.select(bands).rename(new_bands);
}



// Filter Sentinel-2 collection
var s2Filt = s2.filterBounds(SK)
                .filterDate(startDate,endDate)
                .filterMetadata('CLOUDY_PIXEL_PERCENTAGE',
                                'less_than',50)
                .map(maskS2srClouds)
                .map(renameBandsETM);

print('Sentinel-2 Filtered collection',s2Filt);



////checking the name of band names
print(s2Filt.first().bandNames());

// Composite images
var s2composite = s2Filt.median().clip(SK); // can be changed to mean, min, etc 

// Add composite to map
Map.addLayer(s2composite,{bands:['sB4','sB3','sB2'],min:0.02,max:0.3,
                          gamma:1.5},'Sentinel-2 2019 composite');



// ============ PRE-PROCESSING  ================= //

// ============ BRDF CORRECTION ================= //
// This snippet is adapted from:
//     mdpi.com/2072-4292/11/7/831/htm#app1-remotesensing-11-00831
    
    
    

var PI = ee.Number(3.14159265359);
var MAX_SATELLITE_ZENITH = 7.5;
var MAX_DISTANCE = 1000000;
var UPPER_LEFT = 0;
var LOWER_LEFT = 1;
var LOWER_RIGHT = 2;
var UPPER_RIGHT = 3;

//   Creates a collection of mosaics with a given temporal interval.

//   collection - the collection from which to make composites.
//   start - the date of the first composite (either a string or an ee.Date)
//   count - the number of composites to make
//   interval - The time between composites, in units of "units".
// units - The units of step (day, week, month, year; see ee ee.Date.advance)

exports.brdfL8 = function(collection) {

  collection = collection.map(applyBRDF);
  return collection;

  function applyBRDF(image){
    var date = image.date();
    var footprint = ee.List(image.geometry().bounds().bounds().coordinates().get(0));
    var angles =  getsunAngles(date, footprint);
    var sunAz = angles[0];
    var sunZen = angles[1];
  
    var viewAz = azimuth(footprint);
    var viewZen = zenith(footprint);
  
  
    var kval = _kvol(sunAz, sunZen, viewAz, viewZen);
    var kvol = kval[0];
    var kvol0 = kval[1];
    var result = _apply(image, kvol.multiply(PI), kvol0.multiply(PI));
  
    return result;}

  //  Get sunAngles from the map given the data.
  // 
  //  date:  ee.date object
  //  footprint: geometry of the image
  // 
  function getsunAngles(date, footprint){
    var jdp = date.getFraction('year');
    var seconds_in_hour = 3600;
    var  hourGMT = ee.Number(date.getRelative('second', 'day')).divide(seconds_in_hour);
    
    var latRad = ee.Image.pixelLonLat().select('latitude').multiply(PI.divide(180));
    var longDeg = ee.Image.pixelLonLat().select('longitude');
    
    // Julian day proportion in radians
    var jdpr = jdp.multiply(PI).multiply(2);
    
    var a = ee.List([0.000075, 0.001868, 0.032077, 0.014615, 0.040849]);
    var meanSolarTime = longDeg.divide(15.0).add(ee.Number(hourGMT));
    var localSolarDiff1 = value(a, 0)
            .add(value(a, 1).multiply(jdpr.cos())) 
            .subtract(value(a, 2).multiply(jdpr.sin())) 
            .subtract(value(a, 3).multiply(jdpr.multiply(2).cos())) 
            .subtract(value(a, 4).multiply(jdpr.multiply(2).sin()));
  
    var localSolarDiff2 = localSolarDiff1.multiply(12 * 60);
  
    var localSolarDiff = localSolarDiff2.divide(PI);
    var trueSolarTime = meanSolarTime 
            .add(localSolarDiff.divide(60)) 
            .subtract(12.0);
    
    // Hour as an angle;
    var ah = trueSolarTime.multiply(ee.Number(MAX_SATELLITE_ZENITH * 2).multiply(PI.divide(180))) ;   
    var b = ee.List([0.006918, 0.399912, 0.070257, 0.006758, 0.000907, 0.002697, 0.001480]);
    var delta = value(b, 0) 
          .subtract(value(b, 1).multiply(jdpr.cos())) 
          .add(value(b, 2).multiply(jdpr.sin())) 
          .subtract(value(b, 3).multiply(jdpr.multiply(2).cos())) 
          .add(value(b, 4).multiply(jdpr.multiply(2).sin())) 
          .subtract(value(b, 5).multiply(jdpr.multiply(3).cos())) 
          .add(value(b, 6).multiply(jdpr.multiply(3).sin()));
  
    var cosSunZen = latRad.sin().multiply(delta.sin()) 
          .add(latRad.cos().multiply(ah.cos()).multiply(delta.cos()));
    var sunZen = cosSunZen.acos();
  
    // sun azimuth from south, turning west
    var sinSunAzSW = ah.sin().multiply(delta.cos()).divide(sunZen.sin());
    sinSunAzSW = sinSunAzSW.clamp(-1.0, 1.0);
  
    var cosSunAzSW = (latRad.cos().multiply(-1).multiply(delta.sin())
                    .add(latRad.sin().multiply(delta.cos()).multiply(ah.cos()))) 
                    .divide(sunZen.sin());
    var sunAzSW = sinSunAzSW.asin();
  
    sunAzSW = where(cosSunAzSW.lte(0), sunAzSW.multiply(-1).add(PI), sunAzSW);
    sunAzSW = where(cosSunAzSW.gt(0).and(sinSunAzSW.lte(0)), sunAzSW.add(PI.multiply(2)), sunAzSW);
  
    var sunAz = sunAzSW.add(PI);
    // # Keep within [0, 2pi] range
    sunAz = where(sunAz.gt(PI.multiply(2)), sunAz.subtract(PI.multiply(2)), sunAz);
  
    var footprint_polygon = ee.Geometry.Polygon(footprint);
    sunAz = sunAz.clip(footprint_polygon);
    sunAz = sunAz.rename(['sunAz']);
    sunZen = sunZen.clip(footprint_polygon).rename(['sunZen']);
  
    return [sunAz, sunZen];
  }


  //  Get azimuth.
  // 
  //  
  //  footprint: geometry of the image
  // 
  function azimuth(footprint){

    function x(point){return ee.Number(ee.List(point).get(0))}
    function  y(point){return ee.Number(ee.List(point).get(1))}
    
      var upperCenter = line_from_coords(footprint, UPPER_LEFT, UPPER_RIGHT).centroid().coordinates();
      var lowerCenter = line_from_coords(footprint, LOWER_LEFT, LOWER_RIGHT).centroid().coordinates();
      var slope = ((y(lowerCenter)).subtract(y(upperCenter))).divide((x(lowerCenter)).subtract(x(upperCenter)));
      var slopePerp = ee.Number(-1).divide(slope);
      var azimuthLeft = ee.Image(PI.divide(2).subtract((slopePerp).atan()));
      return azimuthLeft.rename(['viewAz']);
  }

  //  Get zenith.
  // 
  //  
  //  footprint: geometry of the image
  // 
  function zenith(footprint){
      var leftLine = line_from_coords(footprint, UPPER_LEFT, LOWER_LEFT);
      var rightLine = line_from_coords(footprint, UPPER_RIGHT, LOWER_RIGHT);
      var leftDistance = ee.FeatureCollection(leftLine).distance(MAX_DISTANCE);
      var rightDistance = ee.FeatureCollection(rightLine).distance(MAX_DISTANCE);
      var viewZenith = rightDistance.multiply(ee.Number(MAX_SATELLITE_ZENITH * 2)) 
          .divide(rightDistance.add(leftDistance)) 
          .subtract(ee.Number(MAX_SATELLITE_ZENITH)) 
          .clip(ee.Geometry.Polygon(footprint)) 
          .rename(['viewZen']);
    return viewZenith.multiply(PI.divide(180));
  }
  
  //  apply function to all bands
  // 
  //  http://www.mdpi.com/2072-4292/9/12/1325/htm#sec3dot2-remotesensing-09-01325 
  //  https://www.sciencedirect.com/science/article/pii/S0034425717302791
  // 
  //  image : the image to apply the function to
  //  kvol:
  //  kvol0
  // 
  // 
function _apply(image, kvol, kvol0){
      var f_iso = 0;
      var f_geo = 0;
      var f_vol = 0;
			var blue = _correct_band(image, 'blue', kvol, kvol0, f_iso=0.0774, f_geo=0.0079, f_vol=0.0372);
			var green = _correct_band(image, 'green', kvol, kvol0, f_iso=0.1306, f_geo=0.0178, f_vol=0.0580);
			var red = _correct_band(image, 'red', kvol, kvol0, f_iso=0.1690, f_geo=0.0227, f_vol=0.0574);
			var re1 = _correct_band(image, 're1', kvol, kvol0, f_iso=0.2085, f_geo=0.0256, f_vol=0.0845);
			var re2 = _correct_band(image, 're2', kvol, kvol0, f_iso=0.2316, f_geo=0.0273, f_vol=0.1003);
			var re3 = _correct_band(image, 're3', kvol, kvol0, f_iso=0.2599, f_geo=0.0294, f_vol=0.1197);
      var nir = _correct_band(image, 'nir', kvol, kvol0, f_iso=0.3093, f_geo=0.0330, f_vol=0.1535);
      var re4 = _correct_band(image, 're4', kvol, kvol0, f_iso=0.2907, f_geo=0.0410, f_vol=0.1611);
      var swir1 = _correct_band(image, 'swir1', kvol, kvol0, f_iso=0.3430, f_geo=0.0453, f_vol=0.1154);   
      var swir2 = _correct_band(image, 'swir2', kvol, kvol0, f_iso=0.2658, f_geo=0.0387, f_vol=0.0639);
			return image.select([]).addBands([blue, green, red, nir,re1,re2,re3,nir,re4,swir1, swir2]);
}

  //  correct band function
  // 
  // 
  //  image : the image to apply the function to
  //  band_name
  //  kvol
  //  kvol0
  //  f_iso
  //  f_geo
  //  f_vol
  // 
  //   
  function _correct_band(image, band_name, kvol, kvol0, f_iso, f_geo, f_vol){
			//"""fiso + fvol * kvol + fgeo * kgeo"""
			var iso = ee.Image(f_iso);
			var geo = ee.Image(f_geo);
			var vol = ee.Image(f_vol);
			var pred = vol.multiply(kvol).add(geo.multiply(kvol)).add(iso).rename(['pred']);
			var pred0 = vol.multiply(kvol0).add(geo.multiply(kvol0)).add(iso).rename(['pred0']);
			var cfac = pred0.divide(pred).rename(['cfac']);
			var corr = image.select(band_name).multiply(cfac).rename([band_name]);
			return corr;
  }

  //  calculate kvol and kvol0
  // 
  //  sunAZ
  //  sunZen
  //  viewAz
  //  viewZen
  // 
  //  
  function _kvol(sunAz, sunZen, viewAz, viewZen){
			//"""Calculate kvol kernel.
			//From Lucht et al. 2000
			//Phase angle = cos(solar zenith) cos(view zenith) + sin(solar zenith) sin(view zenith) cos(relative azimuth)"""
			
			var relative_azimuth = sunAz.subtract(viewAz).rename(['relAz']);
			var pa1 = viewZen.cos().multiply(sunZen.cos());
			var pa2 = viewZen.sin().multiply(sunZen.sin()).multiply(relative_azimuth.cos());
			var phase_angle1 = pa1.add(pa2);
			var phase_angle = phase_angle1.acos();
			var p1 = ee.Image(PI.divide(2)).subtract(phase_angle);
			var p2 = p1.multiply(phase_angle1);
			var p3 = p2.add(phase_angle.sin());
			var p4 = sunZen.cos().add(viewZen.cos());
			var p5 = ee.Image(PI.divide(4));

			var kvol = p3.divide(p4).subtract(p5).rename(['kvol']);

			var viewZen0 = ee.Image(0);
			var pa10 = viewZen0.cos().multiply(sunZen.cos());
			var pa20 = viewZen0.sin().multiply(sunZen.sin()).multiply(relative_azimuth.cos());
			var phase_angle10 = pa10.add(pa20);
			var phase_angle0 = phase_angle10.acos();
			var p10 = ee.Image(PI.divide(2)).subtract(phase_angle0);
			var p20 = p10.multiply(phase_angle10);
			var p30 = p20.add(phase_angle0.sin());
			var p40 = sunZen.cos().add(viewZen0.cos());
			var p50 = ee.Image(PI.divide(4));

			var kvol0 = p30.divide(p40).subtract(p50).rename(['kvol0']);

			return [kvol, kvol0]}

  //  helper function
  // 
  //  
  // 
  //   
                             
  function line_from_coords(coordinates, fromIndex, toIndex){
      return ee.Geometry.LineString(ee.List([
        coordinates.get(fromIndex),
        coordinates.get(toIndex)]));
  }

  function where(condition, trueValue, falseValue){
        var trueMasked = trueValue.mask(condition);
        var falseMasked = falseValue.mask(invertMask(condition));
        return trueMasked.unmask(falseMasked);
    }
  
    function invertMask(mask){
      return mask.multiply(-1).add(1);
    }


    function value(list,index){
      return ee.Number(list.get(index));
    }

};


//  Creates a collection of mosaics with a given temporal interval.
// 
//  collection - the collection from which to make composites.
//  start - the date of the first composite (either a string or an ee.Date)
//  count - the number of composites to make
//  interval - The time between composites, in units of "units".
//  units - The units of step (day, week, month, year; see ee ee.Date.advance)
// 
exports.brdfL8 = function(collection) {
collection = collection.map(applyBRDF);
  return collection;
function applyBRDF(image) {
  var date = image.date();
  var footprint = ee.List(image.geometry().bounds().bounds().coordinates().get(0));
  var angles =  getsunAngles(date, footprint);
  var sunAz = angles[0];
  var sunZen = angles[1];

  var viewAz = azimuth(footprint);
  var viewZen = zenith(footprint);


  var kval = _kvol(sunAz, sunZen, viewAz, viewZen);
  var kvol = kval[0];
  var kvol0 = kval[1];
  var result = _apply(image, kvol.multiply(PI), kvol0.multiply(PI));
  
  return result;}

  //  Get sunAngles from the map given the data.
  //
  //  date:  ee.date object
  //  footprint: geometry of the image
  // 
  function getsunAngles(date, footprint){
    var jdp = date.getFraction('year');
    var seconds_in_hour = 3600;
    var  hourGMT = ee.Number(date.getRelative('second', 'day')).divide(seconds_in_hour);
    
    var latRad = ee.Image.pixelLonLat().select('latitude').multiply(PI.divide(180));
    var longDeg = ee.Image.pixelLonLat().select('longitude');
    
    // Julian day proportion in radians
    var jdpr = jdp.multiply(PI).multiply(2);
    
    var a = ee.List([0.000075, 0.001868, 0.032077, 0.014615, 0.040849]);
    var meanSolarTime = longDeg.divide(15.0).add(ee.Number(hourGMT));
    var localSolarDiff1 = value(a, 0)
            .add(value(a, 1).multiply(jdpr.cos())) 
            .subtract(value(a, 2).multiply(jdpr.sin())) 
            .subtract(value(a, 3).multiply(jdpr.multiply(2).cos())) 
            .subtract(value(a, 4).multiply(jdpr.multiply(2).sin()));
  
    var localSolarDiff2 = localSolarDiff1.multiply(12 * 60);
  
    var localSolarDiff = localSolarDiff2.divide(PI);
    var trueSolarTime = meanSolarTime 
            .add(localSolarDiff.divide(60)) 
            .subtract(12.0);
    
    // Hour as an angle;
    var ah = trueSolarTime.multiply(ee.Number(MAX_SATELLITE_ZENITH * 2).multiply(PI.divide(180))) ;   
    var b = ee.List([0.006918, 0.399912, 0.070257, 0.006758, 0.000907, 0.002697, 0.001480]);
    var delta = value(b, 0) 
          .subtract(value(b, 1).multiply(jdpr.cos())) 
          .add(value(b, 2).multiply(jdpr.sin())) 
          .subtract(value(b, 3).multiply(jdpr.multiply(2).cos())) 
          .add(value(b, 4).multiply(jdpr.multiply(2).sin())) 
          .subtract(value(b, 5).multiply(jdpr.multiply(3).cos())) 
          .add(value(b, 6).multiply(jdpr.multiply(3).sin()));
  
    var cosSunZen = latRad.sin().multiply(delta.sin()) 
          .add(latRad.cos().multiply(ah.cos()).multiply(delta.cos()));
    var sunZen = cosSunZen.acos();
  
    // sun azimuth from south, turning west
    var sinSunAzSW = ah.sin().multiply(delta.cos()).divide(sunZen.sin());
    sinSunAzSW = sinSunAzSW.clamp(-1.0, 1.0);
  
    var cosSunAzSW = (latRad.cos().multiply(-1).multiply(delta.sin())
                    .add(latRad.sin().multiply(delta.cos()).multiply(ah.cos()))) 
                    .divide(sunZen.sin());
    var sunAzSW = sinSunAzSW.asin();
  
    sunAzSW = where(cosSunAzSW.lte(0), sunAzSW.multiply(-1).add(PI), sunAzSW);
    sunAzSW = where(cosSunAzSW.gt(0).and(sinSunAzSW.lte(0)), sunAzSW.add(PI.multiply(2)), sunAzSW);
  
    var sunAz = sunAzSW.add(PI);
    // # Keep within [0, 2pi] range
    sunAz = where(sunAz.gt(PI.multiply(2)), sunAz.subtract(PI.multiply(2)), sunAz);
  
    var footprint_polygon = ee.Geometry.Polygon(footprint);
    sunAz = sunAz.clip(footprint_polygon);
    sunAz = sunAz.rename(['sunAz']);
    sunZen = sunZen.clip(footprint_polygon).rename(['sunZen']);
  
    return [sunAz, sunZen];
  }


  // Get azimuth.
  // 
  //  
  //  footprint: geometry of the image
  // 
  function azimuth(footprint){

    function x(point){return ee.Number(ee.List(point).get(0))}
    function  y(point){return ee.Number(ee.List(point).get(1))}
    
      var upperCenter = line_from_coords(footprint, UPPER_LEFT, UPPER_RIGHT).centroid().coordinates();
      var lowerCenter = line_from_coords(footprint, LOWER_LEFT, LOWER_RIGHT).centroid().coordinates();
      var slope = ((y(lowerCenter)).subtract(y(upperCenter))).divide((x(lowerCenter)).subtract(x(upperCenter)));
      var slopePerp = ee.Number(-1).divide(slope);
      var azimuthLeft = ee.Image(PI.divide(2).subtract((slopePerp).atan()));
      return azimuthLeft.rename(['viewAz']);
  }

  //  Get zenith.
  // 
  //  
  // footprint: geometry of the image
  // 
  function zenith(footprint){
      var leftLine = line_from_coords(footprint, UPPER_LEFT, LOWER_LEFT);
      var rightLine = line_from_coords(footprint, UPPER_RIGHT, LOWER_RIGHT);
      var leftDistance = ee.FeatureCollection(leftLine).distance(MAX_DISTANCE);
      var rightDistance = ee.FeatureCollection(rightLine).distance(MAX_DISTANCE);
      var viewZenith = rightDistance.multiply(ee.Number(MAX_SATELLITE_ZENITH * 2)) 
          .divide(rightDistance.add(leftDistance)) 
          .subtract(ee.Number(MAX_SATELLITE_ZENITH)) 
          .clip(ee.Geometry.Polygon(footprint)) 
          .rename(['viewZen']);
    return viewZenith.multiply(PI.divide(180));
  }
  
  //  apply function to all bands
  // 
  //  http://www.mdpi.com/2072-4292/9/12/1325/htm#sec3dot2-remotesensing-09-01325 
  //  https://www.sciencedirect.com/science/article/pii/S0034425717302791
  // 
  //  image : the image to apply the function to
  //  kvol:
  //  kvol0
  // 
  // 
function _apply(image, kvol, kvol0){
      var f_iso = 0;
      var f_geo = 0;
      var f_vol = 0;
			var blue = _correct_band(image, 'blue', kvol, kvol0, f_iso=0.0774, f_geo=0.0079, f_vol=0.0372);
			var green = _correct_band(image, 'green', kvol, kvol0, f_iso=0.1306, f_geo=0.0178, f_vol=0.0580);
			var red = _correct_band(image, 'red', kvol, kvol0, f_iso=0.1690, f_geo=0.0227, f_vol=0.0574);
      var nir = _correct_band(image, 'nir', kvol, kvol0, f_iso=0.3093, f_geo=0.0330, f_vol=0.1535);
      var swir1 = _correct_band(image, 'swir1', kvol, kvol0, f_iso=0.3430, f_geo=0.0453, f_vol=0.1154);   
      var swir2 = _correct_band(image, 'swir2', kvol, kvol0, f_iso=0.2658, f_geo=0.0387, f_vol=0.0639);
      var DOY = image.select("DOY")
			return image.select([]).addBands([blue, green, red, nir, swir1, swir2,DOY]);
}

  //  correct band function
  // 
  // 
  //  image : the image to apply the function to
  //  band_name
  //  kvol
  //  kvol0
  //  f_iso
  //  f_geo
  //  f_vol
  // 
  //   
  function _correct_band(image, band_name, kvol, kvol0, f_iso, f_geo, f_vol){
			//"""fiso + fvol * kvol + fgeo * kgeo"""
			var iso = ee.Image(f_iso);
			var geo = ee.Image(f_geo);
			var vol = ee.Image(f_vol);
			var pred = vol.multiply(kvol).add(geo.multiply(kvol)).add(iso).rename(['pred']);
			var pred0 = vol.multiply(kvol0).add(geo.multiply(kvol0)).add(iso).rename(['pred0']);
			var cfac = pred0.divide(pred).rename(['cfac']);
			var corr = image.select(band_name).multiply(cfac).rename([band_name]);
			return corr;
  }

  //  calculate kvol and kvol0
  // 
  //  sunAZ
  //  sunZen
  //  viewAz
  //  viewZen
  // 
  //   
  function _kvol(sunAz, sunZen, viewAz, viewZen){
			//"""Calculate kvol kernel.
			//From Lucht et al. 2000
			//Phase angle = cos(solar zenith) cos(view zenith) + sin(solar zenith) sin(view zenith) cos(relative azimuth)"""
			
			var relative_azimuth = sunAz.subtract(viewAz).rename(['relAz']);
			var pa1 = viewZen.cos().multiply(sunZen.cos());
			var pa2 = viewZen.sin().multiply(sunZen.sin()).multiply(relative_azimuth.cos());
			var phase_angle1 = pa1.add(pa2);
			var phase_angle = phase_angle1.acos();
			var p1 = ee.Image(PI.divide(2)).subtract(phase_angle);
			var p2 = p1.multiply(phase_angle1);
			var p3 = p2.add(phase_angle.sin());
			var p4 = sunZen.cos().add(viewZen.cos());
			var p5 = ee.Image(PI.divide(4));

			var kvol = p3.divide(p4).subtract(p5).rename(['kvol']);

			var viewZen0 = ee.Image(0);
			var pa10 = viewZen0.cos().multiply(sunZen.cos());
			var pa20 = viewZen0.sin().multiply(sunZen.sin()).multiply(relative_azimuth.cos());
			var phase_angle10 = pa10.add(pa20);
			var phase_angle0 = phase_angle10.acos();
			var p10 = ee.Image(PI.divide(2)).subtract(phase_angle0);
			var p20 = p10.multiply(phase_angle10);
			var p30 = p20.add(phase_angle0.sin());
			var p40 = sunZen.cos().add(viewZen0.cos());
			var p50 = ee.Image(PI.divide(4));

			var kvol0 = p30.divide(p40).subtract(p50).rename(['kvol0']);

			return [kvol, kvol0]}

  //  helper function
  // 
  //  
  // 
  //   
                             
  function line_from_coords(coordinates, fromIndex, toIndex){
      return ee.Geometry.LineString(ee.List([
        coordinates.get(fromIndex),
        coordinates.get(toIndex)]));
  }

  function where(condition, trueValue, falseValue){
        var trueMasked = trueValue.mask(condition);
        var falseMasked = falseValue.mask(invertMask(condition));
        return trueMasked.unmask(falseMasked);
    }
  
    function invertMask(mask){
      return mask.multiply(-1).add(1);
    }


    function value(list,index){
      return ee.Number(list.get(index));
    }

};

// =========================== END OF BRDF ======================= //



// ========== CLOUD AND CLOUD-SHADOW MASKING  =====================//

// =========================== CLOUD MASKING =============== //

// 9. Cloud and cloud shadow masking parameters.
// If cloudScoreTDOM is chosen
// cloudScoreThresh: If using the cloudScoreTDOMShift method-Threshold for cloud 
//    masking (lower number masks more clouds.  Between 10 and 30 generally 
//    works best)
var cloudScoreThresh = 20;

// Percentile of cloud score to pull from time series to represent a minimum for 
// the cloud score over time for a given pixel. Reduces commission errors over 
// cool bright surfaces. Generally between 5 and 10 works well. 0 generally is a
// bit noisy
var cloudScorePctl = 0; 

// contractPixels: The radius of the number of pixels to contract (negative 
//    buffer) clouds and cloud shadows by. Intended to eliminate smaller cloud 
//    patches that are likely errors
// (1.5 results in a -1 pixel buffer)(0.5 results in a -0 pixel buffer)
// (1.5 or 2.5 generally is sufficient)
var contractPixels = 1.5; 

// dilatePixels: The radius of the number of pixels to dilate (buffer) clouds 
//    and cloud shadows by. Intended to include edges of clouds/cloud shadows 
//    that are often missed
// (1.5 results in a 1 pixel buffer)(0.5 results in a 0 pixel buffer)
// (2.5 or 3.5 generally is sufficient)
var dilatePixels = 2.5;




////////////////////////////////////////////////////////////////////////////////
// Compute a cloud score and adds a band that represents the cloud mask.  
// This expects the input image to have the common band names: 
// ["red", "blue", etc], so it can work across sensors.
exports.landsatCloudScore = function(ls8,cloudScoreThresh,cloudScorePctl,contractPixels,dilatePixels){
  function getCloudScore (img) {
  // Compute several indicators of cloudiness and take the minimum of them.
  var score = ee.Image(1.0);
  // Clouds are reasonably bright in the blue band.
  score = score.min(rescale(img, 'img.blue', [0.1, 0.3]));
 
  // Clouds are reasonably bright in all visible bands.
  score = score.min(rescale(img, 'img.red + img.green + img.blue', [0.2, 0.8]));
   
  // Clouds are reasonably bright in all infrared bands.
  score = score.min(
    rescale(img, 'img.nir + img.swir1 + img.swir2', [0.3, 0.8]));

  // Clouds are reasonably cool in temperature.
  score = score.min(rescale(img,'img.temp', [300, 290]));

  // However, clouds are not snow.
  var ndsi = img.normalizedDifference(['green', 'swir1']);
  score = score.min(rescale(ndsi, 'img', [0.8, 0.6]));
  
  // var ss = snowScore(img).select(['snowScore']);
  // score = score.min(rescale(ss, 'img', [0.3, 0]));
  
  score = score.multiply(100).byte();
  score = score.clamp(0,100);
  return img.addBands(score.rename(['cloudScore']));
}

function maskScore(img){
    //var cloudMask = img.select(['cloudScore']).subtract(minCloudScore).lt(cloudScoreThresh)
    //                                          .focal_max(contractPixels).focal_min(dilatePixels).rename('cloudMask');
    var cloudMask = img.select(['cloudScore']).lt(cloudScoreThresh).focal_max(contractPixels).focal_min(dilatePixels).rename('cloudMask');
    return img .updateMask(cloudMask).addBands(cloudMask);
  }
  

ls8 = ls8.map(getCloudScore);

 // Find low cloud score pctl for each pixel to avoid comission errors
  var minCloudScore = ls8.select(['cloudScore']).reduce(ee.Reducer.percentile([cloudScorePctl]));

  ls8 = ls8.map(maskScore);


return ls8
};


exports.QAMaskCloud = function(ls8){
////////////////////////////////////////////////////////////////////////////////
// Functions for applying fmask to SR data with QA band
var fmaskBitDict = {'cloud' : 32, 'shadow': 8,'snow':16};

function cFmask(img,fmaskClass){
  var m = img.select('pixel_qa').bitwiseAnd(fmaskBitDict[fmaskClass]).neq(0);
  return img.updateMask(m.not());
}
function cFmaskCloud(img){
  return cFmask(img,'cloud');
}
function cFmaskCloudShadow(img){
  return cFmask(img,'shadow');
}

  
  ls8 = ls8.map(cFmaskCloud).map(cFmaskCloudShadow)
  return ls8
};

////////////////////////////////////////////////////////////////////////////////
// Helper function to apply an expression and linearly rescale the output.
// Used in the sentinelCloudScore function below.
function rescale(img, exp, thresholds) {
  return img.expression(exp, {img: img})
    .subtract(thresholds[0]).divide(thresholds[1] - thresholds[0]);
}


//  =========================== END CLOUD MASKING ===================== //


// =========================== CLOUD SHADOW REMOVAL =================== //
// zScoreThresh: Threshold for cloud shadow masking- lower number masks out 
//    less. Between -0.8 and -1.2 generally works well
var zScoreThresh = -1;

// shadowSumThresh: Sum of IR bands to include as shadows within TDOM and the 
//    shadow shift method (lower number masks out less)
var shadowSumThresh = 0.35;

// contractPixels: The radius of the number of pixels to contract (negative 
//    buffer) clouds and cloud shadows by. Intended to eliminate smaller cloud 
//    patches that are likely errors
// (1.5 results in a -1 pixel buffer)(0.5 results in a -0 pixel buffer)
// (1.5 or 2.5 generally is sufficient)
var contractPixels = 1.5; 

// dilatePixels: The radius of the number of pixels to dilate (buffer) clouds 
//    and cloud shadows by. Intended to include edges of clouds/cloud shadows 
//    that are often missed
// (1.5 results in a 1 pixel buffer)(0.5 results in a 0 pixel buffer)
// (2.5 or 3.5 generally is sufficient)
var dilatePixels = 2.5;


////////////////////////////////////////////////////////////////////////////////
// Function for finding dark outliers in time series.
// Original concept written by Carson Stam and adapted by Ian Housman.
// Adds a band that is a mask of pixels that are dark, and dark outliers.
exports.shadowMask = function(collection,studyArea,zScoreThresh,shadowSumThresh,contractPixels,dilatePixels) {

  var shadowSumBands = ['nir','swir1'];
  
  var allCollection = ee.ImageCollection("LANDSAT/LC08/C01/T1_SR").filterBounds(studyArea).select(["B5","B6"],shadowSumBands);
  // Get some pixel-wise stats for the time series
  var irStdDev = allCollection.select(shadowSumBands).reduce(ee.Reducer.stdDev());
  var irMean = allCollection.select(shadowSumBands).mean();
  
  var maskDarkOutliers = function(img){
      var zScore = img.select(shadowSumBands).subtract(irMean).divide(irStdDev);
      var irSum = img.select(shadowSumBands).reduce(ee.Reducer.sum());
      var TDOMMask = zScore.lt(zScoreThresh).reduce(ee.Reducer.sum()).eq(2).and(irSum.lt(shadowSumThresh));
      
      TDOMMask = TDOMMask.focal_min(contractPixels).focal_max(dilatePixels).rename('TDOMMask');
      return img.updateMask(TDOMMask.not()).addBands(TDOMMask);
  };  
  
  // Mask out dark dark outliers
  collection = collection.map(maskDarkOutliers);

  return collection;
};

// =========================== END CLOUD SHADOW REMOVAL =============== //


// TERRAIN CORRECTION

// ======================= TERRAIN CORRECTIONS ==================== //
var scale = 300;
var toaOrSR = 'SR';

// get terrain layers
var dem = ee.Image("USGS/SRTMGL1_003");
var degree2radian = 0.01745;

exports.terrainCorrection = function(collection) {

  collection = collection.map(illuminationCondition);
  collection = collection.map(illuminationCorrection);


  return(collection);

  ////////////////////////////////////////////////////////////////////////////////
  // Function to calculate illumination condition (IC). Function by Patrick Burns 
  // (pb463@nau.edu) and Matt Macander 
  // (mmacander@abrinc.com)
  function illuminationCondition(img){

  // Extract image metadata about solar position
  var SZ_rad = ee.Image.constant(ee.Number(img.get('SOLAR_ZENITH_ANGLE'))).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000)); 
  var SA_rad = ee.Image.constant(ee.Number(img.get('SOLAR_AZIMUTH_ANGLE')).multiply(3.14159265359).divide(180)).clip(img.geometry().buffer(10000)); 
  // Creat terrain layers
  var slp = ee.Terrain.slope(dem).clip(img.geometry().buffer(10000));
  var slp_rad = ee.Terrain.slope(dem).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000));
  var asp_rad = ee.Terrain.aspect(dem).multiply(3.14159265359).divide(180).clip(img.geometry().buffer(10000));
  
  // Calculate the Illumination Condition (IC)
  // slope part of the illumination condition
  var cosZ = SZ_rad.cos();
  var cosS = slp_rad.cos();
  var slope_illumination = cosS.expression("cosZ * cosS", 
                                          {'cosZ': cosZ,
                                           'cosS': cosS.select('slope')});
  // aspect part of the illumination condition
  var sinZ = SZ_rad.sin(); 
  var sinS = slp_rad.sin();
  var cosAziDiff = (SA_rad.subtract(asp_rad)).cos();
  var aspect_illumination = sinZ.expression("sinZ * sinS * cosAziDiff", 
                                           {'sinZ': sinZ,
                                            'sinS': sinS,
                                            'cosAziDiff': cosAziDiff});
  // full illumination condition (IC)
  var ic = slope_illumination.add(aspect_illumination);

  // Add IC to original image
  var img_plus_ic = ee.Image(img.addBands(ic.rename('IC')).addBands(cosZ.rename('cosZ')).addBands(cosS.rename('cosS')).addBands(slp.rename('slope')));
  return img_plus_ic;
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Function to apply the Sun-Canopy-Sensor + C (SCSc) correction method to each 
  // image. Function by Patrick Burns (pb463@nau.edu) and Matt Macander 
  // (mmacander@abrinc.com)
  function illuminationCorrection(img){
    var props = img.toDictionary();
    var st = img.get('system:time_start');
    
    var img_plus_ic = img;
    var mask1 = img_plus_ic.select('nir').gt(-0.1);
    var mask2 = img_plus_ic.select('slope').gte(5)
                            .and(img_plus_ic.select('IC').gte(0))
                            .and(img_plus_ic.select('nir').gt(-0.1));
    var img_plus_ic_mask2 = ee.Image(img_plus_ic.updateMask(mask2));
    
    // Specify Bands to topographically correct  
    var bandList = ['blue','green','red','nir','swir1','swir2']; 
    var compositeBands = img.bandNames();
    var nonCorrectBands = img.select(compositeBands.removeAll(bandList));
    
    var geom = ee.Geometry(img.get('system:footprint')).bounds().buffer(10000);
    
    function apply_SCSccorr(band){
      var method = 'SCSc';
      var out =  ee.Image(1).addBands(img_plus_ic_mask2.select('IC', band))
                            .reduceRegion({reducer: ee.Reducer.linearRegression(2,1),
                                           geometry: ee.Geometry(img.geometry()),
                                           scale: scale,
                                           bestEffort :true,
                                           maxPixels:1e10});
 
        var fit = out.combine({"coefficients": ee.Array([[1],[1]])}, false);
 
                //Get the coefficients as a nested list,
                // ast it to an array, and get just the selected column
                var out_a = (ee.Array(fit.get('coefficients')).get([0,0]));
                var out_b = (ee.Array(fit.get('coefficients')).get([1,0]));
                var out_c = out_a.divide(out_b);
 
        // Apply the SCSc correction
        var SCSc_output = img_plus_ic_mask2.expression(
        "((image * (cosB * cosZ + cvalue)) / (ic + cvalue))", {
        'image': img_plus_ic_mask2.select(band),
        'ic': img_plus_ic_mask2.select('IC'),
        'cosB': img_plus_ic_mask2.select('cosS'),
        'cosZ': img_plus_ic_mask2.select('cosZ'),
        'cvalue': out_c
        });
 
      return SCSc_output;
 
    }
 
    var img_SCSccorr = ee.Image(bandList.map(apply_SCSccorr)).addBands(img_plus_ic.select('IC'));
    var bandList_IC = ee.List([bandList, 'IC']).flatten();
    img_SCSccorr = img_SCSccorr.unmask(img_plus_ic.select(bandList_IC)).select(bandList);
 
  
    img_SCSccorr = ee.Image(img_SCSccorr.addBands(nonCorrectBands).setMulti(props).set('system:time_start',st))
    return img_SCSccorr.select(['red','green','blue','nir','swir1','swir2',"DOY"])  
  }
  
}  
// ==================================== END OF TERRAIN CORRECTION ===================== //


// ************************************************ //
// NORMALIZE ALL THE COVARIATES AND BANDS  (come back later)         //
//************************************************* //
/*
// Normalize the image 

// Machine learning algorithms work best on images when all features have
// the same range

// Function to Normalize Image
// Pixel Values should be between 0 and 1
// Formula is (x - xmin) / (xmax - xmin)
//************************************************************************** 
function normalize(image){
  var bandNames = image.bandNames();
  // Compute min and max of the image
  var minDict = image.reduceRegion({
    reducer: ee.Reducer.min(),
    geometry: boundary,
    scale: 10,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 16
  });
  var maxDict = image.reduceRegion({
    reducer: ee.Reducer.max(),
    geometry: boundary,
    scale: 10,
    maxPixels: 1e9,
    bestEffort: true,
    tileScale: 16
  });
  var mins = ee.Image.constant(minDict.values(bandNames));
  var maxs = ee.Image.constant(maxDict.values(bandNames));

  var normalized = image.subtract(mins).divide(maxs.subtract(mins))
  return normalized
}
*/


// *****************************************************************//
//                      spectral indices
//*****************************************************************
//Example using image.expression()

/*
// Load a Landsat 8 image.
var image = ee.Image('LANDSAT/LC08/C02/T1_TOA/LC08_044034_20140318');

// Compute the EVI using an expression.
var evi = image.expression(
    '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR': image.select('B5'),
      'RED': image.select('B4'),
      'BLUE': image.select('B2')
});

Map.centerObject(image, 9);
Map.addLayer(evi, {min: -1, max: 1, palette: ['a6611a', 'f5f5f5', '4dac26']});
*/

//===========  Indices that i will include  ==============
/*
// ========= 
// for sentinel-2 and landsat-8
//============

var NBR = image.expression(
    '(NIR - SWIR)/(NIR + SWIR)', {
      'NIR': image.select('B5'),
      'RED': image.select('B4')
    });
    

var MSWI = image.expression(
    '(1-NIR)/((NIR + SWIR) * (NIR - RED) * 100)', {
      'NIR': image.select('B5'),
      'RED': image.select('B4'),
      'SWIR': image.select('B6')
});

var NDSI = image.expression(
    '(SWIR2 - BLUE)/(SWIR2 + BLUE)', {
      'BLUE': image.select('B2'),
      'SWIR': image.select('B6') //CHANGE TO B11 FOR s2
});

var NDWI = image.expression(
    '(GREEN - NIR)/(GREEN + NIR)', {
      'GREEN': image.select('B3'),
      'NIR': image.select('B5') //CHANGE TO B8 FOR s2
});

var BIa = image.expression(
    'sqrt((RED)**2 + (GREEN)**2 + (NIR)**2)',{
      'GREEN': image.select('B3'),
      'NIR': image.select('B8'), //CHANGE TO B5 FOR L8
      'RED': image.select('B4')  
});

var BIb = image.expression(
    'sqrt((RED)**2 + (GREEN)**2)',{
      'GREEN': image.select('B3'),
      'RED': image.select('B4')  
});

var NDBI = image.expression(
    '(SWIR2 - NIR)/(SWIR2 + NIR)', {
      'SWIR2': image.select('B11'), //CHANGE TO B7 FOR L8
      'NIR': image.select('B5') 
});

var BSI = image.expression(
    '((SWIR2 + RED) - (SWIR2 + BLUE))/((SWIR2 + RED) + (SWIR2 + BLUE))', {
      'SWIR2': image.select('B11'), //CHANGE TO B7 FOR L8
      'RED': image.select('B4'),
      'BLUE': image.select('B2')
});


var MSAVI = image.expression(
    '(2 * NIR + 1 – sqrt ((2 * NIR + 1)2 – 8 * (NIR – RED)))', {
      'RED': image.select('B4'),
      'NIR': image.select('B5') //CHANGE TO B8 for S2
});

var MBSI = image.expression(
    '((RED - GREEN)*2)/((RED + GREEN)-2)', {
      'RED': image.select('B4'), //CHANGE TO B4 FOR L8
      'GREEN': image.select('B3') 
});

// ========= 
// for sentinel-1 
//============


// ========= 
// for PALSAR 
//============
*/

// *****************************************************************//
//                      add several spectral indices over image collections
//*****************************************************************


/// generate Sentine-1 average of VH and VV polarization data for 2020.
// Sentinel-1 is from the European Space Agency (ESA) and operates at C-band in VV and VH polarization.
// VH or HV are more sensitive to volume and plants.  VV is about roughness such as surface waves on water.
var pol = 'VH';
var pol2 = 'VV';

// Define resolution, will also be used to define the output resolution\
// The possible resolutions are 10, 25, or 40 meters
var res = 10;

var collectionVH = ee.ImageCollection('COPERNICUS/S1_GRD')
   .filterBounds(SK)
   .filterDate(startDate, endDate)
   .select(pol);

var collectionVV = ee.ImageCollection('COPERNICUS/S1_GRD')
   .filterBounds(SK)
   .filterDate(startDate, endDate)
   .select(pol2);

//Compute the mean of the Sentinel-1 data collection over the period specfied above by start and end. 
//Then rename that band as 's1vh' so we can call and access it directly later
var S1_VH_mean = collectionVH.reduce(ee.Reducer.mean()).rename('s1vh');
var S1_VV_mean = collectionVV.reduce(ee.Reducer.mean()).rename('s1vv');

var s1Vis = {
  min: -20,
  max: -5,
};

S1_VH_mean = S1_VH_mean.clip(SK);
S1_VV_mean = S1_VV_mean.clip(SK);



//The Map.addLayer simply displays the image with the visualization parameters specfied above and inserted in command below.
// Let's called that displayed image as 'Sentinel-1 VH'
Map.addLayer(S1_VH_mean, s1Vis, 'Sentinel-1 VH');
Map.addLayer(S1_VV_mean, s1Vis, 'Sentinel-1 VV');


// Use these bands for prediction.
//var bands = ['B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11','s1vh', 's1vv', 'sB3','sB4','sB5'];  

//  Now add that Sentinel-1 mean backscksatter to the stack of Landsat bands with the following command:
var allimages = compositel8.addBands(S1_VH_mean);
var allimages = allimages.addBands(S1_VV_mean);
var allimages = allimages.addBands(s2composite);

////checking the name of band names again
print(allimages.bandNames());


/////////////////////// Now, lets' add ALOS/PALSAR mosaics from JAXA. ///////////////////////////////////////////////
//////////// These are produced every year by JAXA. This is L-band data at HV and HH ////

var alos = ee.Image('JAXA/ALOS/PALSAR/YEARLY/SAR/2017');

//  compute the HV/HH ratio and add as new Band
var hvhh = alos.expression(
  '(HV/HH)', {
    'HH': alos.select('HH'),
    'HV': alos.select('HV')
}).rename('HVHH');

var alos = alos.addBands(hvhh);

// apply: γ₀ = 10log₁₀(DN²) - 83.0 dB
var DN = alos.select('HH');
var HVdB = DN.pow(2).log10().multiply(10).subtract(83);
HVdB = HVdB.rename(['HV'])  /// naming that band 'HV' for calling later


var alosHVVis = {
  min: -20,
  max: -5,
};
HVdB = HVdB.clip(SK);

var palsarVis = {
  min: -20,
  max: -5,
};


Map.addLayer(HVdB, palsarVis, 'Palsar');

//  Now add that ALOS band
var allimages = allimages.addBands(HVdB);


////checking the name of band names again
print(allimages.bandNames());

var bands = ['HV','B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B10', 'B11','s1vh', 's1vv', 'sB3','sB4','sB5'];

// Overlay the  on the imagery to get training data. That is the value of each band in the variable 'bands' above are
var training = allimages.select(bands).sampleRegions({
  collection: classNames,  ///set this equal to the training data you wish to use mygeeclasses or mygee or what ever else you have defined.
  properties: ['landcover'],
  scale: 20
});
//print('landcover',training);

// Train a CART classifier with the above training data, labels and the bands. You can see the values for each training pixel
// in the 'Console' window on the right because it was printed in the line above.
var trained = ee.Classifier.smileCart().train(training, 'landcover', bands);

// Classify the image with the same bands used for training. 'tained' is the actual decision tree model and can be applied to the
// entire image
var classified = allimages.select(bands).classify(trained);  //'classified' is my new classification map

// Display the inputs and the results.

// the following is simply for setting associating each class_id to HTML color code. You should change those, add or remove items if you
// have more or less classes.  you can select your favorite colors by copy/paste the code from here https://htmlcolorcodes.com/
var mypalette=[  'red', // ASGM
  'black', // Forest
  'blue', //  nonforestVeg
  'green',  // settlements
  'yellow', // baresoil
  'cyan', //waterbody
 
];

Map.addLayer(classified, //displaying the classification map
             {min: 0, max: 6, palette: mypalette},  // using my choice of color for each class
             'Classification'); // call this layer 'classification
             

//add all the necessary polygon for this
Map.addLayer(MineKal, {}, "Mines in Kalimantan");



//************************************************************************** 
// Accuracy Assessment (COME BACK HERE AGAIN LATER!)
//************************************************************************** 

//merge the Test class
var classNamesTest = TASGM.merge(TForest).merge(TnonforestVeg).merge(Tsettlements).merge(TbareSoil).merge(TwaterBody);

// https://courses.spatialthoughts.com/end-to-end-gee.html#accuracy-assessment
// Use classification map to assess accuracy using the validation fraction
// of the overall training set created above.
var test = classified.sampleRegions({
  collection: classNamesTest,
  properties: ['landcover'],
  scale: 20,
});

var testConfusionMatrix = test.errorMatrix('landcover', 'classification')
// Printing of confusion matrix may time out. Alternatively, you can export it as CSV
print('Confusion Matrix', testConfusionMatrix);
print('Test Accuracy', testConfusionMatrix.accuracy());

//Later print out the confusion matrix

//COME BACK LATER!!!!


//===========================================================================//


// Just try to export this to GoogleDrive
// Export.image.toDrive({
//   image: classified,
//   description: 'classify_220926',
//   crs: 'EPSG:3857',
//   fileFormat: 'GeoTIFF',
//   maxPixels: 1e9,
//   formatOptions: {
//     cloudOptimized:true
//   }
// });

//************************************************************************** 
// Post-processing (COME BACK HERE AGAIN LATER!)
//************************************************************************** 


// get back here for post-processing improvement, how? dunno


// Can i try to iterate the classification process


var PABorneo = ee.FeatureCollection(PABorneo);
Map.addLayer(PABorneo, {}, "PA in Borneo");

// PA in Borneio 
